{"version":3,"file":"address-formatter.js","sources":["../../node_modules/mustache/mustache.mjs","../../src/internal.js","../../src/index.js"],"sourcesContent":["/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\nvar objectToString = Object.prototype.toString;\nvar isArray = Array.isArray || function isArrayPolyfill (object) {\n  return objectToString.call(object) === '[object Array]';\n};\n\nfunction isFunction (object) {\n  return typeof object === 'function';\n}\n\n/**\n * More correct typeof string handling array\n * which normally returns typeof 'object'\n */\nfunction typeStr (obj) {\n  return isArray(obj) ? 'array' : typeof obj;\n}\n\nfunction escapeRegExp (string) {\n  return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, '\\\\$&');\n}\n\n/**\n * Null safe way of checking whether or not an object,\n * including its prototype, has a given property\n */\nfunction hasProperty (obj, propName) {\n  return obj != null && typeof obj === 'object' && (propName in obj);\n}\n\n/**\n * Safe way of detecting whether or not the given thing is a primitive and\n * whether it has the given property\n */\nfunction primitiveHasOwnProperty (primitive, propName) {\n  return (\n    primitive != null\n    && typeof primitive !== 'object'\n    && primitive.hasOwnProperty\n    && primitive.hasOwnProperty(propName)\n  );\n}\n\n// Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n// See https://github.com/janl/mustache.js/issues/189\nvar regExpTest = RegExp.prototype.test;\nfunction testRegExp (re, string) {\n  return regExpTest.call(re, string);\n}\n\nvar nonSpaceRe = /\\S/;\nfunction isWhitespace (string) {\n  return !testRegExp(nonSpaceRe, string);\n}\n\nvar entityMap = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n  '/': '&#x2F;',\n  '`': '&#x60;',\n  '=': '&#x3D;'\n};\n\nfunction escapeHtml (string) {\n  return String(string).replace(/[&<>\"'`=\\/]/g, function fromEntityMap (s) {\n    return entityMap[s];\n  });\n}\n\nvar whiteRe = /\\s*/;\nvar spaceRe = /\\s+/;\nvar equalsRe = /\\s*=/;\nvar curlyRe = /\\s*\\}/;\nvar tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n/**\n * Breaks up the given `template` string into a tree of tokens. If the `tags`\n * argument is given here it must be an array with two string values: the\n * opening and closing tags used in the template (e.g. [ \"<%\", \"%>\" ]). Of\n * course, the default is to use mustaches (i.e. mustache.tags).\n *\n * A token is an array with at least 4 elements. The first element is the\n * mustache symbol that was used inside the tag, e.g. \"#\" or \"&\". If the tag\n * did not contain a symbol (i.e. {{myValue}}) this element is \"name\". For\n * all text that appears outside a symbol this element is \"text\".\n *\n * The second element of a token is its \"value\". For mustache tags this is\n * whatever else was inside the tag besides the opening symbol. For text tokens\n * this is the text itself.\n *\n * The third and fourth elements of the token are the start and end indices,\n * respectively, of the token in the original template.\n *\n * Tokens that are the root node of a subtree contain two more elements: 1) an\n * array of tokens in the subtree and 2) the index in the original template at\n * which the closing tag for that section begins.\n *\n * Tokens for partials also contain two more elements: 1) a string value of\n * indendation prior to that tag and 2) the index of that tag on that line -\n * eg a value of 2 indicates the partial is the third tag on this line.\n */\nfunction parseTemplate (template, tags) {\n  if (!template)\n    return [];\n  var lineHasNonSpace = false;\n  var sections = [];     // Stack to hold section tokens\n  var tokens = [];       // Buffer to hold the tokens\n  var spaces = [];       // Indices of whitespace tokens on the current line\n  var hasTag = false;    // Is there a {{tag}} on the current line?\n  var nonSpace = false;  // Is there a non-space char on the current line?\n  var indentation = '';  // Tracks indentation for tags that use it\n  var tagIndex = 0;      // Stores a count of number of tags encountered on a line\n\n  // Strips all whitespace tokens array for the current line\n  // if there was a {{#tag}} on it and otherwise only space.\n  function stripSpace () {\n    if (hasTag && !nonSpace) {\n      while (spaces.length)\n        delete tokens[spaces.pop()];\n    } else {\n      spaces = [];\n    }\n\n    hasTag = false;\n    nonSpace = false;\n  }\n\n  var openingTagRe, closingTagRe, closingCurlyRe;\n  function compileTags (tagsToCompile) {\n    if (typeof tagsToCompile === 'string')\n      tagsToCompile = tagsToCompile.split(spaceRe, 2);\n\n    if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)\n      throw new Error('Invalid tags: ' + tagsToCompile);\n\n    openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\\\s*');\n    closingTagRe = new RegExp('\\\\s*' + escapeRegExp(tagsToCompile[1]));\n    closingCurlyRe = new RegExp('\\\\s*' + escapeRegExp('}' + tagsToCompile[1]));\n  }\n\n  compileTags(tags || mustache.tags);\n\n  var scanner = new Scanner(template);\n\n  var start, type, value, chr, token, openSection;\n  while (!scanner.eos()) {\n    start = scanner.pos;\n\n    // Match any text between tags.\n    value = scanner.scanUntil(openingTagRe);\n\n    if (value) {\n      for (var i = 0, valueLength = value.length; i < valueLength; ++i) {\n        chr = value.charAt(i);\n\n        if (isWhitespace(chr)) {\n          spaces.push(tokens.length);\n          indentation += chr;\n        } else {\n          nonSpace = true;\n          lineHasNonSpace = true;\n          indentation += ' ';\n        }\n\n        tokens.push([ 'text', chr, start, start + 1 ]);\n        start += 1;\n\n        // Check for whitespace on the current line.\n        if (chr === '\\n') {\n          stripSpace();\n          indentation = '';\n          tagIndex = 0;\n          lineHasNonSpace = false;\n        }\n      }\n    }\n\n    // Match the opening tag.\n    if (!scanner.scan(openingTagRe))\n      break;\n\n    hasTag = true;\n\n    // Get the tag type.\n    type = scanner.scan(tagRe) || 'name';\n    scanner.scan(whiteRe);\n\n    // Get the tag value.\n    if (type === '=') {\n      value = scanner.scanUntil(equalsRe);\n      scanner.scan(equalsRe);\n      scanner.scanUntil(closingTagRe);\n    } else if (type === '{') {\n      value = scanner.scanUntil(closingCurlyRe);\n      scanner.scan(curlyRe);\n      scanner.scanUntil(closingTagRe);\n      type = '&';\n    } else {\n      value = scanner.scanUntil(closingTagRe);\n    }\n\n    // Match the closing tag.\n    if (!scanner.scan(closingTagRe))\n      throw new Error('Unclosed tag at ' + scanner.pos);\n\n    if (type == '>') {\n      token = [ type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace ];\n    } else {\n      token = [ type, value, start, scanner.pos ];\n    }\n    tagIndex++;\n    tokens.push(token);\n\n    if (type === '#' || type === '^') {\n      sections.push(token);\n    } else if (type === '/') {\n      // Check section nesting.\n      openSection = sections.pop();\n\n      if (!openSection)\n        throw new Error('Unopened section \"' + value + '\" at ' + start);\n\n      if (openSection[1] !== value)\n        throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n    } else if (type === 'name' || type === '{' || type === '&') {\n      nonSpace = true;\n    } else if (type === '=') {\n      // Set the tags for the next time around.\n      compileTags(value);\n    }\n  }\n\n  stripSpace();\n\n  // Make sure there are no open sections when we're done.\n  openSection = sections.pop();\n\n  if (openSection)\n    throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n\n  return nestTokens(squashTokens(tokens));\n}\n\n/**\n * Combines the values of consecutive text tokens in the given `tokens` array\n * to a single token.\n */\nfunction squashTokens (tokens) {\n  var squashedTokens = [];\n\n  var token, lastToken;\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n    token = tokens[i];\n\n    if (token) {\n      if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\n        lastToken[1] += token[1];\n        lastToken[3] = token[3];\n      } else {\n        squashedTokens.push(token);\n        lastToken = token;\n      }\n    }\n  }\n\n  return squashedTokens;\n}\n\n/**\n * Forms the given array of `tokens` into a nested tree structure where\n * tokens that represent a section have two additional items: 1) an array of\n * all tokens that appear in that section and 2) the index in the original\n * template that represents the end of that section.\n */\nfunction nestTokens (tokens) {\n  var nestedTokens = [];\n  var collector = nestedTokens;\n  var sections = [];\n\n  var token, section;\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n    token = tokens[i];\n\n    switch (token[0]) {\n      case '#':\n      case '^':\n        collector.push(token);\n        sections.push(token);\n        collector = token[4] = [];\n        break;\n      case '/':\n        section = sections.pop();\n        section[5] = token[2];\n        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;\n        break;\n      default:\n        collector.push(token);\n    }\n  }\n\n  return nestedTokens;\n}\n\n/**\n * A simple string scanner that is used by the template parser to find\n * tokens in template strings.\n */\nfunction Scanner (string) {\n  this.string = string;\n  this.tail = string;\n  this.pos = 0;\n}\n\n/**\n * Returns `true` if the tail is empty (end of string).\n */\nScanner.prototype.eos = function eos () {\n  return this.tail === '';\n};\n\n/**\n * Tries to match the given regular expression at the current position.\n * Returns the matched text if it can match, the empty string otherwise.\n */\nScanner.prototype.scan = function scan (re) {\n  var match = this.tail.match(re);\n\n  if (!match || match.index !== 0)\n    return '';\n\n  var string = match[0];\n\n  this.tail = this.tail.substring(string.length);\n  this.pos += string.length;\n\n  return string;\n};\n\n/**\n * Skips all text until the given regular expression can be matched. Returns\n * the skipped string, which is the entire tail if no match can be made.\n */\nScanner.prototype.scanUntil = function scanUntil (re) {\n  var index = this.tail.search(re), match;\n\n  switch (index) {\n    case -1:\n      match = this.tail;\n      this.tail = '';\n      break;\n    case 0:\n      match = '';\n      break;\n    default:\n      match = this.tail.substring(0, index);\n      this.tail = this.tail.substring(index);\n  }\n\n  this.pos += match.length;\n\n  return match;\n};\n\n/**\n * Represents a rendering context by wrapping a view object and\n * maintaining a reference to the parent context.\n */\nfunction Context (view, parentContext) {\n  this.view = view;\n  this.cache = { '.': this.view };\n  this.parent = parentContext;\n}\n\n/**\n * Creates a new context using the given view with this context\n * as the parent.\n */\nContext.prototype.push = function push (view) {\n  return new Context(view, this);\n};\n\n/**\n * Returns the value of the given name in this context, traversing\n * up the context hierarchy if the value is absent in this context's view.\n */\nContext.prototype.lookup = function lookup (name) {\n  var cache = this.cache;\n\n  var value;\n  if (cache.hasOwnProperty(name)) {\n    value = cache[name];\n  } else {\n    var context = this, intermediateValue, names, index, lookupHit = false;\n\n    while (context) {\n      if (name.indexOf('.') > 0) {\n        intermediateValue = context.view;\n        names = name.split('.');\n        index = 0;\n\n        /**\n         * Using the dot notion path in `name`, we descend through the\n         * nested objects.\n         *\n         * To be certain that the lookup has been successful, we have to\n         * check if the last object in the path actually has the property\n         * we are looking for. We store the result in `lookupHit`.\n         *\n         * This is specially necessary for when the value has been set to\n         * `undefined` and we want to avoid looking up parent contexts.\n         *\n         * In the case where dot notation is used, we consider the lookup\n         * to be successful even if the last \"object\" in the path is\n         * not actually an object but a primitive (e.g., a string, or an\n         * integer), because it is sometimes useful to access a property\n         * of an autoboxed primitive, such as the length of a string.\n         **/\n        while (intermediateValue != null && index < names.length) {\n          if (index === names.length - 1)\n            lookupHit = (\n              hasProperty(intermediateValue, names[index])\n              || primitiveHasOwnProperty(intermediateValue, names[index])\n            );\n\n          intermediateValue = intermediateValue[names[index++]];\n        }\n      } else {\n        intermediateValue = context.view[name];\n\n        /**\n         * Only checking against `hasProperty`, which always returns `false` if\n         * `context.view` is not an object. Deliberately omitting the check\n         * against `primitiveHasOwnProperty` if dot notation is not used.\n         *\n         * Consider this example:\n         * ```\n         * Mustache.render(\"The length of a football field is {{#length}}{{length}}{{/length}}.\", {length: \"100 yards\"})\n         * ```\n         *\n         * If we were to check also against `primitiveHasOwnProperty`, as we do\n         * in the dot notation case, then render call would return:\n         *\n         * \"The length of a football field is 9.\"\n         *\n         * rather than the expected:\n         *\n         * \"The length of a football field is 100 yards.\"\n         **/\n        lookupHit = hasProperty(context.view, name);\n      }\n\n      if (lookupHit) {\n        value = intermediateValue;\n        break;\n      }\n\n      context = context.parent;\n    }\n\n    cache[name] = value;\n  }\n\n  if (isFunction(value))\n    value = value.call(this.view);\n\n  return value;\n};\n\n/**\n * A Writer knows how to take a stream of tokens and render them to a\n * string, given a context. It also maintains a cache of templates to\n * avoid the need to parse the same template twice.\n */\nfunction Writer () {\n  this.templateCache = {\n    _cache: {},\n    set: function set (key, value) {\n      this._cache[key] = value;\n    },\n    get: function get (key) {\n      return this._cache[key];\n    },\n    clear: function clear () {\n      this._cache = {};\n    }\n  };\n}\n\n/**\n * Clears all cached templates in this writer.\n */\nWriter.prototype.clearCache = function clearCache () {\n  if (typeof this.templateCache !== 'undefined') {\n    this.templateCache.clear();\n  }\n};\n\n/**\n * Parses and caches the given `template` according to the given `tags` or\n * `mustache.tags` if `tags` is omitted,  and returns the array of tokens\n * that is generated from the parse.\n */\nWriter.prototype.parse = function parse (template, tags) {\n  var cache = this.templateCache;\n  var cacheKey = template + ':' + (tags || mustache.tags).join(':');\n  var isCacheEnabled = typeof cache !== 'undefined';\n  var tokens = isCacheEnabled ? cache.get(cacheKey) : undefined;\n\n  if (tokens == undefined) {\n    tokens = parseTemplate(template, tags);\n    isCacheEnabled && cache.set(cacheKey, tokens);\n  }\n  return tokens;\n};\n\n/**\n * High-level method that is used to render the given `template` with\n * the given `view`.\n *\n * The optional `partials` argument may be an object that contains the\n * names and templates of partials that are used in the template. It may\n * also be a function that is used to load partial templates on the fly\n * that takes a single argument: the name of the partial.\n *\n * If the optional `config` argument is given here, then it should be an\n * object with a `tags` attribute or an `escape` attribute or both.\n * If an array is passed, then it will be interpreted the same way as\n * a `tags` attribute on a `config` object.\n *\n * The `tags` attribute of a `config` object must be an array with two\n * string values: the opening and closing tags used in the template (e.g.\n * [ \"<%\", \"%>\" ]). The default is to mustache.tags.\n *\n * The `escape` attribute of a `config` object must be a function which\n * accepts a string as input and outputs a safely escaped string.\n * If an `escape` function is not provided, then an HTML-safe string\n * escaping function is used as the default.\n */\nWriter.prototype.render = function render (template, view, partials, config) {\n  var tags = this.getConfigTags(config);\n  var tokens = this.parse(template, tags);\n  var context = (view instanceof Context) ? view : new Context(view, undefined);\n  return this.renderTokens(tokens, context, partials, template, config);\n};\n\n/**\n * Low-level method that renders the given array of `tokens` using\n * the given `context` and `partials`.\n *\n * Note: The `originalTemplate` is only ever used to extract the portion\n * of the original template that was contained in a higher-order section.\n * If the template doesn't use higher-order sections, this argument may\n * be omitted.\n */\nWriter.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate, config) {\n  var buffer = '';\n\n  var token, symbol, value;\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n    value = undefined;\n    token = tokens[i];\n    symbol = token[0];\n\n    if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate, config);\n    else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate, config);\n    else if (symbol === '>') value = this.renderPartial(token, context, partials, config);\n    else if (symbol === '&') value = this.unescapedValue(token, context);\n    else if (symbol === 'name') value = this.escapedValue(token, context, config);\n    else if (symbol === 'text') value = this.rawValue(token);\n\n    if (value !== undefined)\n      buffer += value;\n  }\n\n  return buffer;\n};\n\nWriter.prototype.renderSection = function renderSection (token, context, partials, originalTemplate, config) {\n  var self = this;\n  var buffer = '';\n  var value = context.lookup(token[1]);\n\n  // This function is used to render an arbitrary template\n  // in the current context by higher-order sections.\n  function subRender (template) {\n    return self.render(template, context, partials, config);\n  }\n\n  if (!value) return;\n\n  if (isArray(value)) {\n    for (var j = 0, valueLength = value.length; j < valueLength; ++j) {\n      buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);\n    }\n  } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {\n    buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);\n  } else if (isFunction(value)) {\n    if (typeof originalTemplate !== 'string')\n      throw new Error('Cannot use higher-order sections without the original template');\n\n    // Extract the portion of the original template that the section contains.\n    value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);\n\n    if (value != null)\n      buffer += value;\n  } else {\n    buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);\n  }\n  return buffer;\n};\n\nWriter.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate, config) {\n  var value = context.lookup(token[1]);\n\n  // Use JavaScript's definition of falsy. Include empty arrays.\n  // See https://github.com/janl/mustache.js/issues/186\n  if (!value || (isArray(value) && value.length === 0))\n    return this.renderTokens(token[4], context, partials, originalTemplate, config);\n};\n\nWriter.prototype.indentPartial = function indentPartial (partial, indentation, lineHasNonSpace) {\n  var filteredIndentation = indentation.replace(/[^ \\t]/g, '');\n  var partialByNl = partial.split('\\n');\n  for (var i = 0; i < partialByNl.length; i++) {\n    if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {\n      partialByNl[i] = filteredIndentation + partialByNl[i];\n    }\n  }\n  return partialByNl.join('\\n');\n};\n\nWriter.prototype.renderPartial = function renderPartial (token, context, partials, config) {\n  if (!partials) return;\n  var tags = this.getConfigTags(config);\n\n  var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];\n  if (value != null) {\n    var lineHasNonSpace = token[6];\n    var tagIndex = token[5];\n    var indentation = token[4];\n    var indentedValue = value;\n    if (tagIndex == 0 && indentation) {\n      indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);\n    }\n    var tokens = this.parse(indentedValue, tags);\n    return this.renderTokens(tokens, context, partials, indentedValue, config);\n  }\n};\n\nWriter.prototype.unescapedValue = function unescapedValue (token, context) {\n  var value = context.lookup(token[1]);\n  if (value != null)\n    return value;\n};\n\nWriter.prototype.escapedValue = function escapedValue (token, context, config) {\n  var escape = this.getConfigEscape(config) || mustache.escape;\n  var value = context.lookup(token[1]);\n  if (value != null)\n    return (typeof value === 'number' && escape === mustache.escape) ? String(value) : escape(value);\n};\n\nWriter.prototype.rawValue = function rawValue (token) {\n  return token[1];\n};\n\nWriter.prototype.getConfigTags = function getConfigTags (config) {\n  if (isArray(config)) {\n    return config;\n  }\n  else if (config && typeof config === 'object') {\n    return config.tags;\n  }\n  else {\n    return undefined;\n  }\n};\n\nWriter.prototype.getConfigEscape = function getConfigEscape (config) {\n  if (config && typeof config === 'object' && !isArray(config)) {\n    return config.escape;\n  }\n  else {\n    return undefined;\n  }\n};\n\nvar mustache = {\n  name: 'mustache.js',\n  version: '4.2.0',\n  tags: [ '{{', '}}' ],\n  clearCache: undefined,\n  escape: undefined,\n  parse: undefined,\n  render: undefined,\n  Scanner: undefined,\n  Context: undefined,\n  Writer: undefined,\n  /**\n   * Allows a user to override the default caching strategy, by providing an\n   * object with set, get and clear methods. This can also be used to disable\n   * the cache by setting it to the literal `undefined`.\n   */\n  set templateCache (cache) {\n    defaultWriter.templateCache = cache;\n  },\n  /**\n   * Gets the default or overridden caching object from the default writer.\n   */\n  get templateCache () {\n    return defaultWriter.templateCache;\n  }\n};\n\n// All high-level mustache.* functions use this writer.\nvar defaultWriter = new Writer();\n\n/**\n * Clears all cached templates in the default writer.\n */\nmustache.clearCache = function clearCache () {\n  return defaultWriter.clearCache();\n};\n\n/**\n * Parses and caches the given template in the default writer and returns the\n * array of tokens it contains. Doing this ahead of time avoids the need to\n * parse templates on the fly as they are rendered.\n */\nmustache.parse = function parse (template, tags) {\n  return defaultWriter.parse(template, tags);\n};\n\n/**\n * Renders the `template` with the given `view`, `partials`, and `config`\n * using the default writer.\n */\nmustache.render = function render (template, view, partials, config) {\n  if (typeof template !== 'string') {\n    throw new TypeError('Invalid template! Template should be a \"string\" ' +\n                        'but \"' + typeStr(template) + '\" was given as the first ' +\n                        'argument for mustache#render(template, view, partials)');\n  }\n\n  return defaultWriter.render(template, view, partials, config);\n};\n\n// Export the escaping function so that the user may override it.\n// See https://github.com/janl/mustache.js/issues/244\nmustache.escape = escapeHtml;\n\n// Export these mainly for testing, but also for advanced usage.\nmustache.Scanner = Scanner;\nmustache.Context = Context;\nmustache.Writer = Writer;\n\nexport default mustache;\n","import Mustache from 'mustache';\nimport templates from './templates/templates.json';\nimport aliases from './templates/aliases.json';\nimport stateCodes from './templates/state-codes.json';\nimport countyCodes from './templates/county-codes.json';\nimport country2lang from './templates/country-to-lang.json';\nimport abbreviations from './templates/abbreviations.json';\n\nconst knownComponents = aliases.map((a) => a.alias);\nconst VALID_REPLACEMENT_COMPONENTS = ['state'];\nconst SMALL_DISTRICT_COUNTRIES = {\n  BR: 1,\n  CR: 1,\n  ES: 1,\n  NI: 1,\n  PY: 1,\n  RO: 1,\n  TG: 1,\n  TM: 1,\n  XK: 1\n};\n\nexport const determineCountryCode = (input, fallbackCountryCode = null) => {\n  let countryCode = input.country_code && input.country_code.toUpperCase();\n  if (!templates[countryCode] && fallbackCountryCode) {\n    countryCode = fallbackCountryCode.toUpperCase();\n  }\n  if (!countryCode || countryCode.length !== 2) {\n    // TODO change this to exceptions\n    return input;\n  }\n  if (countryCode === 'UK') {\n    countryCode = 'GB';\n  }\n\n  if (templates[countryCode] && templates[countryCode].use_country) {\n    const oldCountryCode = countryCode;\n    countryCode = templates[countryCode].use_country.toUpperCase();\n    if (templates[oldCountryCode].change_country) {\n      let newCountry = templates[oldCountryCode].change_country;\n      const componentRegex = /\\$(\\w*)/;\n      const componentMatch = componentRegex.exec(newCountry);\n      if (componentMatch) {\n        if (input[componentMatch[1]]) {\n          newCountry = newCountry.replace(new RegExp(`\\\\$${componentMatch[1]}`), input[componentMatch[1]]);\n        } else {\n          newCountry = newCountry.replace(new RegExp(`\\\\$${componentMatch[1]}`), '');\n        }\n      }\n      input.country = newCountry;\n    }\n    if (templates[oldCountryCode].add_component && templates[oldCountryCode].add_component.indexOf('=') > -1) {\n      const splitted = templates[oldCountryCode].add_component.split('=');\n      if (VALID_REPLACEMENT_COMPONENTS.indexOf(splitted[0]) > -1) {\n        input[splitted[0]] = splitted[1];\n      }\n    }\n  }\n\n  if (countryCode === 'NL' && input.state) {\n    if (input.state === 'Curaçao') {\n      countryCode = 'CW';\n      input.country = 'Curaçao';\n    } else if (input.state.match(/sint maarten/i)) {\n      countryCode = 'SX';\n      input.country = 'Sint Maarten';\n    } else if (input.state.match(/aruba/i)) {\n      countryCode = 'AW';\n      input.country = 'Aruba';\n    }\n  }\n\n  // eslint-disable-next-line camelcase\n  input.country_code = countryCode;\n  return input;\n};\n\nexport const normalizeComponentKeys = (input) => {\n  const inputKeys = Object.keys(input);\n  for (let i = 0; i < inputKeys.length; i++) {\n    const snaked = inputKeys[i].replace(/([A-Z])/g, '_$1').toLowerCase();\n    if (knownComponents.indexOf(snaked) > -1 && !input[snaked]) {\n      if (input[inputKeys[i]]) {\n        input[snaked] = input[inputKeys[i]];\n      }\n      delete input[inputKeys[i]];\n    }\n  }\n  return input;\n};\n\nexport const applyAliases = (input) => {\n  const inputKeys = Object.keys(input);\n  let tailoredAliases = aliases;\n  if (!SMALL_DISTRICT_COUNTRIES[input.country_code]) {\n    tailoredAliases = aliases.filter((a) => a.alias !== 'district');\n    tailoredAliases.push({ alias: 'district', name: 'state_district' });\n  }\n\n  for (let i = 0; i < inputKeys.length; i++) {\n    const alias = tailoredAliases.find((a) => a.alias === inputKeys[i]);\n    if (alias && !input[alias.name]) {\n      input[alias.name] = input[alias.alias];\n    }\n  }\n  return input;\n};\n\nexport const getStateCode = (state, countryCode) => {\n  if (!stateCodes[countryCode]) {\n    return;\n  }\n  // TODO what if state is actually the stateCode?\n  // https://github.com/OpenCageData/perl-Geo-Address-Formatter/blob/master/lib/Geo/Address/Formatter.pm#L526\n  const found = stateCodes[countryCode].find((e) => {\n    if (typeof e.name === 'string' && e.name.toUpperCase() === state.toUpperCase()) {\n      return e;\n    }\n    const variants = Object.values(e.name);\n    const foundVariant = variants.find((e) => e.toUpperCase() === state.toUpperCase());\n    if (foundVariant) {\n      return {\n        key: e.key\n      };\n    }\n    return false;\n  });\n  return found && found.key;\n};\n\nexport const getCountyCode = (county, countryCode) => {\n  if (!countyCodes[countryCode]) {\n    return;\n  }\n  // TODO what if county is actually the countyCode?\n  const found = countyCodes[countryCode].find((e) => {\n    if (typeof e.name === 'string' && e.name.toUpperCase() === county.toUpperCase()) {\n      return e;\n    }\n    const variants = Object.values(e.name);\n    const foundVariant = variants.find((e) => e.toUpperCase() === county.toUpperCase());\n    if (foundVariant) {\n      return {\n        key: e.key\n      };\n    }\n    return false;\n  });\n  return found && found.key;\n};\n\nexport const cleanupInput = (input, replacements = [], options = {}) => {\n  // If the country is a number, use the state as country\n  let inputKeys = Object.keys(input);\n  if (input.country && input.state && Number.isInteger(input.country)) {\n    input.country = input.state;\n    delete input.state;\n  }\n  if (replacements && replacements.length) {\n    for (let i = 0; i < inputKeys.length; i++) {\n      for (let j = 0; j < replacements.length; j++) {\n        const componentRegex = new RegExp(`^${inputKeys[i]}=`);\n        if (replacements[j][0].match(componentRegex)) {\n          const val = replacements[j][0].replace(componentRegex, '');\n          const valRegex = new RegExp(val);\n          if (input[inputKeys[i]].match(valRegex)) {\n            input[inputKeys[i]] = input[inputKeys[i]].replace(valRegex, replacements[j][1]);\n          }\n        } else {\n          input[inputKeys[i]] = `${input[inputKeys[i]]}`.replace(new RegExp(replacements[j][0]), replacements[j][1]);\n        }\n      }\n    }\n  }\n  if (!input.state_code && input.state) {\n    // eslint-disable-next-line camelcase\n    input.state_code = getStateCode(input.state, input.country_code);\n    if (input.state.match(/^washington,? d\\.?c\\.?/i)) {\n      // eslint-disable-next-line camelcase\n      input.state_code = 'DC';\n      input.state = 'District of Columbia';\n      input.city = 'Washington';\n    }\n  }\n  if (!input.county_code && input.county) {\n    // eslint-disable-next-line camelcase\n    input.county_code = getCountyCode(input.county, input.country_code);\n  }\n  const unknownComponents = [];\n  for (let i = 0; i < inputKeys.length; i++) {\n    if (knownComponents.indexOf(inputKeys[i]) === -1) {\n      unknownComponents.push(inputKeys[i]);\n    }\n  }\n  if (unknownComponents.length) {\n    input.attention = unknownComponents.map((c) => input[c]).join(', ');\n  }\n\n  if (input.postcode && options.cleanupPostcode !== false) {\n    // convert to string\n    input.postcode = `${input.postcode}`;\n    const multiCodeRegex = /^(\\d{5}),\\d{5}/;\n    const multiCodeMatch = multiCodeRegex.exec(input.postcode);\n    if (input.postcode.length > 20) {\n      delete input.postcode;\n    // OSM may use postcode ranges\n    } else if (input.postcode.match(/\\d+;\\d+/)) {\n      delete input.postcode;\n    } else if (multiCodeMatch) {\n      input.postcode = multiCodeMatch[1];\n    }\n  }\n\n  if (options.abbreviate && input.country_code && country2lang[input.country_code]) {\n    for (let i = 0; i < country2lang[input.country_code].length; i++) {\n      const lang = country2lang[input.country_code][i];\n      if (abbreviations[lang]) {\n        for (let j = 0; j < abbreviations[lang].length; j++) {\n          if (input[abbreviations[lang][j].component]) {\n            for (let k = 0; k < abbreviations[lang][j].replacements.length; k++) {\n              input[abbreviations[lang][j].component] = input[abbreviations[lang][j].component].replace(\n                new RegExp(`\\\\b${abbreviations[lang][j].replacements[k].src}\\\\b`),\n                abbreviations[lang][j].replacements[k].dest\n              );\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // naive url cleanup, keys might have changed along the cleanup\n  inputKeys = Object.keys(input);\n  for (let i = 0; i < inputKeys.length; i++) {\n    if (`${input[inputKeys[i]]}`.match(/^https?:\\/\\//i)) {\n      delete input[inputKeys[i]];\n    }\n  }\n\n  return input;\n};\n\nexport const findTemplate = (input) => {\n  return templates[input.country_code] ? templates[input.country_code] : templates.default;\n};\n\nexport const chooseTemplateText = (template, input) => {\n  let selected = template.address_template || templates.default.address_template;\n  const threshold = 2;\n  // Choose fallback only when none of these is present\n  const required = ['road', 'postcode'];\n  const missingValuesCnt = required\n    .map((r) => !!input[r])\n    .filter((s) => !s)\n    .length;\n  if (missingValuesCnt === threshold) {\n    selected = template.fallback_template || templates.default.fallback_template;\n  }\n  return selected;\n};\n\nexport const cleanupRender = (text) => {\n  const replacements = [\n    // eslint-disable-next-line no-useless-escape\n    { s: /[\\},\\s]+$/u, d: '' },\n    { s: /^[,\\s]+/u, d: '' },\n    { s: /^- /u, d: '' }, // line starting with dash due to a parameter missing\n    { s: /,\\s*,/u, d: ', ' }, // multiple commas to one\n    { s: /[ \\t]+,[ \\t]+/u, d: ', ' }, // one horiz whitespace behind comma\n    { s: /[ \\t][ \\t]+/u, d: ' ' }, // multiple horiz whitespace to one\n    { s: /[ \\t]\\n/u, d: '\\n' }, // horiz whitespace, newline to newline\n    { s: /\\n,/u, d: '\\n' }, // newline comma to just newline\n    { s: /,,+/u, d: ',' }, // multiple commas to one\n    { s: /,\\n/u, d: '\\n' }, // comma newline to just newline\n    { s: /\\n[ \\t]+/u, d: '\\n' }, // newline plus space to newline\n    { s: /\\n\\n+/u, d: '\\n' } // multiple newline to one\n  ];\n  const dedupe = (inputChunks, glue, modifier = (s) => s) => {\n    const seen = {};\n    const result = [];\n    for (let i = 0; i < inputChunks.length; i++) {\n      const chunk = inputChunks[i].trim();\n      // Special casing New York here, no dedupe for it\n      if (chunk.toLowerCase() === 'new york') {\n        seen[chunk] = 1;\n        result.push(chunk);\n        continue;\n      }\n      if (!seen[chunk]) {\n        seen[chunk] = 1;\n        result.push(modifier(chunk));\n      }\n    }\n    return result.join(glue);\n  };\n  for (let i = 0; i < replacements.length; i++) {\n    text = text.replace(replacements[i].s, replacements[i].d);\n    text = dedupe(text.split('\\n'), '\\n', (s) => {\n      return dedupe(s.split(', '), ', ');\n    });\n  }\n  return text.trim();\n};\n\nexport const renderTemplate = (template, input) => {\n  const templateText = chooseTemplateText(template, input);\n  const templateInput = Object.assign({}, input, {\n    first: () => {\n      return (text, render) => {\n        const possibilities = render(text, input)\n          .split(/\\s*\\|\\|\\s*/)\n          .filter((b) => b.length > 0);\n        return possibilities.length ? possibilities[0] : '';\n      };\n    }\n  });\n\n  let render = cleanupRender(Mustache.render(templateText, templateInput));\n  if (template.postformat_replace) {\n    for (let i = 0; i < template.postformat_replace.length; i++) {\n      const replacement = template.postformat_replace[i];\n      render = render.replace(new RegExp(replacement[0]), replacement[1]);\n    }\n  }\n  render = cleanupRender(render);\n  if (!render.trim().length) {\n    render = cleanupRender(Object.keys(input)\n      .map((i) => input[i])\n      .filter((s) => !!s)\n      .join(', '));\n  }\n\n  return render + '\\n';\n};\n","import * as internal from './internal.js';\nimport * as countryNames from './templates/country-names.json';\n\nconst addressFormatter = {\n  format: (input, options = {\n    abbreviate: false,\n    appendCountry: false,\n    cleanupPostcode: true,\n    countryCode: undefined,\n    fallbackCountryCode: undefined,\n    output: 'string'\n  }) => {\n    let realInput = Object.assign({}, input);\n    realInput = internal.normalizeComponentKeys(realInput);\n    if (options.countryCode) {\n      // eslint-disable-next-line camelcase\n      realInput.country_code = options.countryCode;\n    }\n    realInput = internal.determineCountryCode(realInput, options.fallbackCountryCode);\n    if (options.appendCountry && countryNames[realInput.country_code] && !realInput.country) {\n      realInput.country = countryNames[realInput.country_code];\n    }\n    realInput = internal.applyAliases(realInput);\n    const template = internal.findTemplate(realInput);\n    realInput = internal.cleanupInput(realInput, template.replace, options);\n    const result = internal.renderTemplate(template, realInput);\n    if (options.output === 'array') {\n      return result.split('\\n').filter((f) => !!f);\n    }\n    return result;\n  }\n};\nexport default addressFormatter;\n"],"names":["objectToString","Object","prototype","toString","isArray","Array","object","call","isFunction","escapeRegExp","string","replace","hasProperty","obj","propName","regExpTest","RegExp","test","nonSpaceRe","isWhitespace","re","testRegExp","entityMap","whiteRe","spaceRe","equalsRe","curlyRe","tagRe","Scanner","this","tail","pos","Context","view","parentContext","cache","parent","Writer","templateCache","_cache","set","key","value","get","clear","eos","scan","match","index","substring","length","scanUntil","search","push","lookup","name","primitive","hasOwnProperty","intermediateValue","names","context","lookupHit","indexOf","split","clearCache","parse","template","tags","cacheKey","mustache","join","isCacheEnabled","tokens","undefined","openingTagRe","closingTagRe","closingCurlyRe","lineHasNonSpace","sections","spaces","hasTag","nonSpace","indentation","tagIndex","stripSpace","pop","compileTags","tagsToCompile","Error","start","type","chr","token","openSection","scanner","i","valueLength","charAt","nestedTokens","collector","numTokens","nestTokens","lastToken","squashedTokens","squashTokens","parseTemplate","render","partials","config","getConfigTags","renderTokens","originalTemplate","symbol","buffer","renderSection","renderInverted","renderPartial","unescapedValue","escapedValue","rawValue","self","j","slice","indentPartial","partial","filteredIndentation","partialByNl","indentedValue","escape","getConfigEscape","String","version","defaultWriter","TypeError","s","knownComponents","aliases","map","a","alias","VALID_REPLACEMENT_COMPONENTS","SMALL_DISTRICT_COUNTRIES","BR","CR","ES","NI","PY","RO","TG","TM","XK","determineCountryCode","input","fallbackCountryCode","arguments","countryCode","country_code","toUpperCase","templates","use_country","oldCountryCode","change_country","newCountry","componentRegex","componentMatch","exec","concat","country","add_component","splitted","state","normalizeComponentKeys","inputKeys","keys","snaked","toLowerCase","applyAliases","tailoredAliases","filter","_loop","find","getStateCode","stateCodes","found","e","foundVariant","values","getCountyCode","county","countyCodes","cleanupInput","replacements","options","Number","isInteger","val","valRegex","state_code","city","county_code","unknownComponents","attention","c","postcode","cleanupPostcode","multiCodeRegex","multiCodeMatch","abbreviate","country2lang","lang","abbreviations","component","k","src","dest","findTemplate","default","cleanupRender","text","d","dedupe","inputChunks","glue","modifier","seen","result","chunk","trim","renderTemplate","templateText","selected","address_template","r","fallback_template","chooseTemplateText","templateInput","assign","first","possibilities","b","Mustache","postformat_replace","replacement","addressFormatter","format","appendCountry","output","realInput","internal","countryNames","f"],"mappings":"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"}
/**
 * Copyright (C) 2000 - 2012 Silverpeas
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * As a special exception to the terms and conditions of version 3.0 of
 * the GPL, you may redistribute this Program in connection with Free/Libre
 * Open Source Software ("FLOSS") applications as described in Silverpeas's
 * FLOSS exception.  You should have received a copy of the text describing
 * the FLOSS exception, and it is also available here:
 * "http://www.silverpeas.org/legal/licensing"
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package org.apache.lucene.search.spell;

import java.io.IOException;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

import org.apache.lucene.analysis.WhitespaceAnalyzer;
import org.apache.lucene.document.Document;
import org.apache.lucene.document.Field;
import org.apache.lucene.index.IndexReader;
import org.apache.lucene.index.IndexWriter;
import org.apache.lucene.index.Term;
import org.apache.lucene.search.BooleanClause;
import org.apache.lucene.search.BooleanQuery;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.Query;
import org.apache.lucene.search.ScoreDoc;
import org.apache.lucene.search.TermQuery;
import org.apache.lucene.search.TopDocs;
import org.apache.lucene.store.Directory;

/**
 * <p>
 * Spell Checker class (Main class) <br/>
 * (initially inspired by the David Spencer code).
 * </p>
 * <p>
 * NB : This class had been update by Silverpeas team, itsn't the original version BE CAREFULL if
 * the Lucene library version must be updapted.
 * </p>
 * <p>
 * Example Usage:
 * 
 * <pre>
 * SpellCheckerImpl spellchecker = new SpellCheckerImpl(spellIndexDirectory);
 * // To index a field of a user index:
 * spellchecker.indexDictionary(new LuceneDictionary(my_lucene_reader, a_field));
 * // To index a file containing words:
 * spellchecker.indexDictionary(new PlainTextDictionary(new File(&quot;myfile.txt&quot;)));
 * String[] suggestions = spellchecker.suggestSimilar(&quot;misspelt&quot;, 5);
 * </pre>
 * @version 1.0
 */
public class SpellCheckerImpl {

  /**
   * the temporary container used to store word before results consolidation
   */
  private Set<SuggestWordImpl> words = null;

  /**
   * Field name for each word in the ngram index.
   */
  public static final String F_WORD = "word";

  /**
   * the spell index
   */
  Directory spellIndex;

  /**
   * Boost value for start and end grams
   */
  private float bStart = 2.0f;
  private float bEnd = 1.0f;

  private IndexSearcher searcher;

  // minimum score for hits generated by the spell checker query
  private float minScore = 0.5f;

  private StringDistance sd;

  /**
   * Use the given directory as a spell checker index. The directory is created if it doesn't exist
   * yet.
   * @param spellIndex
   * @throws IOException
   */
  public SpellCheckerImpl(Directory spellIndex, StringDistance sd) throws IOException {
    this.setSpellIndex(spellIndex);
    this.setStringDistance(sd);
    this.words = new HashSet<SuggestWordImpl>();
  }

  public SpellCheckerImpl(Directory spellIndex) throws IOException {
    this(spellIndex, new LevensteinDistance());
  }

  /**
   * Use a different index as the spell checker index or re-open the existing index if
   * <code>spellIndex</code> is the same value as given in the constructor.
   * @param spellIndex
   * @throws IOException
   */
  public void setSpellIndex(Directory spellIndex) throws IOException {
    this.spellIndex = spellIndex;
    if (!IndexReader.indexExists(spellIndex)) {
      IndexWriter writer = new IndexWriter(spellIndex, null, IndexWriter.MaxFieldLength.LIMITED);
      writer.close();
    }
    // close the old searcher, if there was one
    if (searcher != null) {
      searcher.close();
    }
    searcher = new IndexSearcher(this.spellIndex);
  }

  public void setStringDistance(StringDistance sd) {
    this.sd = sd;
  }

  public StringDistance getStringDistance() {
    return sd;
  }

  /**
   * Sets the accuracy 0 &lt; minScore &lt; 1; default 0.5
   */
  public void setAccuracy(float minScore) {
    this.minScore = minScore;
  }

  /**
   * Suggest similar words. This method doesn't return the suggest words, it just execute the
   * search. To get the results call the getSuggestWords() method.
   * @see org.apache.lucene.search.spell.SpellCheckerImpl#getSuggestWords() <p>
   * As the Lucene similarity that is used to fetch the most relevant n-grammed terms is not the
   * same as the edit distance strategy used to calculate the best matching spell-checked word from
   * the hits that Lucene found, one usually has to retrieve a couple of numSug's in order to get
   * the true best match.
   * <p>
   * I.e. if numSug == 1, don't count on that suggestion being the best one. Thus, you should set
   * this value to <b>at least</b> 5 for a good suggestion.
   * @param word the word you want a spell check done on
   * @param numSug the number of suggested words
   * @throws IOException
   */
  public void suggestSimilar(String word, int numSug) throws IOException {
    this.suggestSimilar(word, numSug, null, null, false);
  }

  /**
   * Suggest similar words (optionally restricted to a field of an index). <br>
   * This method doesn't return the suggest words, it just execute the search. To get the results
   * call the getSuggestWords() method.
   * @see org.apache.lucene.search.spell.SpellCheckerImpl#getSuggestWords() <p>
   * As the Lucene similarity that is used to fetch the most relevant n-grammed terms is not the
   * same as the edit distance strategy used to calculate the best matching spell-checked word from
   * the hits that Lucene found, one usually has to retrieve a couple of numSug's in order to get
   * the true best match.
   * <p>
   * I.e. if numSug == 1, don't count on that suggestion being the best one. Thus, you should set
   * this value to <b>at least</b> 5 for a good suggestion.
   * @param word the word you want a spell check done on
   * @param numSug the number of suggested words
   * @param ir the indexReader of the user index (can be null see field param)
   * @param field the field of the user index: if field is not null, the suggested words are
   * restricted to the words present in this field.
   * @param morePopular return only the suggest words that are as frequent or more frequent than the
   * searched word (only if restricted mode = (indexReader!=null and field!=null)
   * @throws IOException
   */
  public void suggestSimilar(String word, int numSug, IndexReader ir,
      String field, boolean morePopular) throws IOException {

    float min = this.minScore;
    final int lengthWord = word.length();

    final int freq = (ir != null && field != null) ? ir.docFreq(new Term(field, word)) : 0;
    final int goalFreq = (morePopular && ir != null && field != null) ? freq : 0;
    // if the word exists in the real index and we don't care for word frequency, return the word
    // itself
    if (!morePopular && freq > 0) {
      return;
    }

    BooleanQuery query = new BooleanQuery();
    String[] grams;
    String key;

    for (int ng = getMin(lengthWord); ng <= getMax(lengthWord); ng++) {

      key = "gram" + ng; // form key

      grams = formGrams(word, ng); // form word into ngrams (allow dups too)

      if (grams.length == 0) {
        continue; // hmm
      }

      if (bStart > 0) { // should we boost prefixes?
        add(query, "start" + ng, grams[0], bStart); // matches start of word

      }
      if (bEnd > 0) { // should we boost suffixes
        add(query, "end" + ng, grams[grams.length - 1], bEnd); // matches end of word

      }
      for (String gram : grams) {
        add(query, key, gram);
      }
    }

    TopDocs topDocs = searcher.search(query, 20);
    // System.out.println("Q: " + query);

    // go thru more than 'maxr' matches in case the distance filter triggers
    int stop = Math.min(topDocs.scoreDocs.length, 10 * numSug);
    SuggestWordImpl sugWord = new SuggestWordImpl();
    ScoreDoc scoreDoc = null;
    for (int i = 0; i < stop; i++) {
      scoreDoc = topDocs.scoreDocs[i];
      sugWord.string = searcher.doc(scoreDoc.doc).get(F_WORD);// get orig word
      // don't suggest a word for itself, that would be silly
      if (sugWord.string.equals(word)) {
        continue;
      }

      // edit distance
      sugWord.score = sd.getDistance(word, sugWord.string);
      if (sugWord.score < min) {
        continue;
      }

      if (ir != null && field != null) { // use the user index
        sugWord.freq = ir.docFreq(new Term(field, sugWord.string)); // freq in the index
        // don't suggest a word that is not present in the field
        if ((morePopular && goalFreq > sugWord.freq) || sugWord.freq < 1) {
          continue;
        }
      }
      words.add(sugWord);

      sugWord = new SuggestWordImpl();
    }

  }

  /**
   * Add a clause to a boolean query.
   */
  private static void add(BooleanQuery q, String name, String value, float boost) {
    Query tq = new TermQuery(new Term(name, value));
    tq.setBoost(boost);
    q.add(new BooleanClause(tq, BooleanClause.Occur.SHOULD));
  }

  /**
   * Add a clause to a boolean query.
   */
  private static void add(BooleanQuery q, String name, String value) {
    q.add(new BooleanClause(new TermQuery(new Term(name, value)), BooleanClause.Occur.SHOULD));
  }

  /**
   * Form all ngrams for a given word.
   * @param text the word to parse
   * @param ng the ngram length e.g. 3
   * @return an array of all ngrams in the word and note that duplicates are not removed
   */
  private static String[] formGrams(String text, int ng) {
    int len = text.length();
    String[] res = new String[len - ng + 1];
    for (int i = 0; i < len - ng + 1; i++) {
      res[i] = text.substring(i, i + ng);
    }
    return res;
  }

  /**
   * Removes all terms from the spell check index.
   * @throws IOException
   */
  public void clearIndex() throws IOException {
    IndexWriter writer = new IndexWriter(spellIndex, null, IndexWriter.MaxFieldLength.LIMITED);
    writer.close();

    // close the old searcher
    searcher.close();
    searcher = new IndexSearcher(this.spellIndex);
  }

  /**
   * Check whether the word exists in the index.
   * @param word
   * @throws IOException
   * @return true iff the word exists in the index
   */
  public boolean exist(String word) throws IOException {
    return searcher.docFreq(new Term(F_WORD, word)) > 0;
  }

  /**
   * Indexes the data from the given {@link Dictionary}.
   * @param dict Dictionary to index
   * @param mergeFactor mergeFactor to use when indexing
   * @param ramMB the max amount or memory in MB to use
   * @throws IOException
   */
  public void indexDictionary(Dictionary dict, int mergeFactor, int ramMB) throws IOException {
    IndexWriter writer =
        new IndexWriter(spellIndex, new WhitespaceAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);
    writer.setMergeFactor(mergeFactor);
    writer.setRAMBufferSizeMB(ramMB);

    Iterator iter = dict.getWordsIterator();
    while (iter.hasNext()) {
      String word = (String) iter.next();

      int len = word.length();
      if (len < 3) {
        continue; // too short we bail but "too long" is fine...
      }

      if (this.exist(word)) { // if the word already exist in the gramindex
        continue;
      }

      // ok index the word
      Document doc = createDocument(word, getMin(len), getMax(len));
      writer.addDocument(doc);
    }
    // close writer
    writer.optimize();
    writer.close();
    // also re-open the spell index to see our own changes when the next suggestion
    // is fetched:
    searcher.close();
    searcher = new IndexSearcher(this.spellIndex);
  }

  /**
   * Indexes the data from the given {@link Dictionary}.
   * @param dict the dictionary to index
   * @throws IOException
   */
  public void indexDictionary(Dictionary dict) throws IOException {
    indexDictionary(dict, 300, 10);
  }

  /**
   * get the suggest words
   * @param numSug number of words to return
   * @return a array of String which contains the suggested words
   */
  public String[] getSuggestWords(int numSug) {
    int resultsSize = words.size();
    // array size
    int suggestWordsSize = numSug;
    if (numSug > resultsSize) {
      suggestWordsSize = resultsSize;
    }
    String[] list = new String[suggestWordsSize];
    SuggestWordQueue sugQueue = new SuggestWordQueue(resultsSize);

    for (SuggestWordImpl sugWord : words) {
      sugQueue.insert(sugWord);
      for (int i = suggestWordsSize - 1; i >= 0; i--) {
        list[i] = ((SuggestWordImpl) sugQueue.pop()).string;
      }
    }
    return list;
  }

  private int getMin(int l) {
    if (l > 5) {
      return 3;
    }
    if (l == 5) {
      return 2;
    }
    return 1;
  }

  private int getMax(int l) {
    if (l > 5) {
      return 4;
    }
    if (l == 5) {
      return 3;
    }
    return 2;
  }

  private static Document createDocument(String text, int ng1, int ng2) {
    Document doc = new Document();
    doc.add(new Field(F_WORD, text, Field.Store.YES, Field.Index.NOT_ANALYZED)); // orig term
    addGram(text, doc, ng1, ng2);
    return doc;
  }

  private static void addGram(String text, Document doc, int ng1, int ng2) {
    int len = text.length();
    for (int ng = ng1; ng <= ng2; ng++) {
      String key = "gram" + ng;
      String end = null;
      for (int i = 0; i < len - ng + 1; i++) {
        String gram = text.substring(i, i + ng);
        doc.add(new Field(key, gram, Field.Store.NO, Field.Index.NOT_ANALYZED));
        if (i == 0) {
          doc.add(new Field("start" + ng, gram, Field.Store.NO, Field.Index.NOT_ANALYZED));
        }
        end = gram;
      }
      if (end != null) { // may not be present if len==ng1
        doc.add(new Field("end" + ng, end, Field.Store.NO, Field.Index.NOT_ANALYZED));
      }
    }
  }
}

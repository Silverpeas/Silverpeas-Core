/*
 * Copyright (C) 2000 - 2024 Silverpeas
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * As a special exception to the terms and conditions of version 3.0 of
 * the GPL, you may redistribute this Program in connection with Free/Libre
 * Open Source Software ("FLOSS") applications as described in Silverpeas's
 * FLOSS exception.  You should have received a copy of the text describing
 * the FLOSS exception, and it is also available here:
 * "https://www.silverpeas.org/legal/floss_exception.html"
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
package org.silverpeas.core.template;

import org.silverpeas.core.template.renderer.DateRenderer;
import org.silverpeas.core.template.renderer.StringRenderer;
import org.silverpeas.core.util.Charsets;
import org.silverpeas.kernel.logging.SilverLogger;
import org.silverpeas.kernel.util.StringUtil;
import org.stringtemplate.v4.*;

import java.io.File;
import java.io.IOException;
import java.io.StringWriter;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;

import static org.apache.commons.io.FileUtils.copyDirectory;

/**
 * Implementation of the Silverpeas templating engine by using StringTemplate v4. The grammar of the
 * templates in Silverpeas have to satisfy the StringTemplate v4 grammar that is summarized in
 * this
 * <a href="https://github.com/antlr/stringtemplate4/blob/master/doc/cheatsheet.md">cheatsheet</a>.
 * <p>
 * By default, the raw templates are used as it was in StringTemplate v3. The difference with the
 * previous version is line-feeds and spaces in the raw templates are considered as such even when
 * coming with statements; for example:
 * <pre>
 *   {@code $if$
 *   $toto$
 * $endif}
 * </pre>
 * will generate a line-feed after the <code>if</code> and the <code>toto</code> statements.
 * </p>
 * <p>
 * Nevertheless, template descriptors are also supported for a better indented templating code or a
 * better control over the template use. A template descriptor is a file containing the
 * definition of a template satisfying the following schema:
 * <pre>
 * {@code <template header> '::=' '<%'<template body>'%>'|'<<'<template body>'>>'
 * with <<template header> = <template name>'('<comma-separated list of attributes>')', and
 * '<%','%>' is to ignore indentation and newlines in multi-lines template body}
 * </pre>
 * </p>
 */
public class SilverpeasStringTemplate implements SilverpeasTemplate {

  private static final Object MUTEX = new Object();
  private static final String MERGED_DIR_NAME = "__merged_delete_me_on_template_modification";
  private final Map<String, Object> attributes = new HashMap<>();
  private final Properties templateConfig;
  private final List<String> paths = new ArrayList<>(3);

  public SilverpeasStringTemplate(Properties templateConfig) {
    this.templateConfig = templateConfig;
    paths.add(templateConfig.getProperty(TEMPLATE_CUSTOM_DIR));
    paths.add(templateConfig.getProperty(TEMPLATE_ROOT_DIR));
  }

  @Override
  public SilverpeasTemplate mergeRootWithCustom() {
    if (paths.size() == 2) {
      final File customPath = new File(paths.get(0));
      if (!customPath.exists()) {
        return this;
      }
      final File rootPath = new File(paths.get(1));
      final File mergedPath = new File(customPath, MERGED_DIR_NAME);
      synchronized (MUTEX) {
        if (!mergedPath.exists()) {
          if (mergedPath.mkdirs()) {
            try {
              copyDirectory(rootPath, mergedPath, true);
              copyDirectory(customPath, mergedPath, f -> !MERGED_DIR_NAME.equals(f.getName()),
                  true);
              paths.add(0, mergedPath.getPath());
            } catch (IOException e) {
              SilverLogger.getLogger(this).error(e);
            }
          }
        } else {
          paths.add(0, mergedPath.getPath());
        }
      }
    }
    return this;
  }

  @Override
  public String applyFileTemplate(final String fileName) {
    return applyTemplate(fileName, getRawGroupDir);
  }

  /**
   * Compiles the declarative template in the specified file and execute the resulting code to
   * generate a full text.
   *
   * @param descriptor the path of the file containing the template definition relative to the root
   * directory of the templates backed by this Silverpeas template.
   * @return the full text generated by the build of the specified template descriptor.
   * @implNote The definition of the template in the file has to be formatted as below:
   * <pre>
   * {@code <template header> '::=' '<%'<template body>'%>'|'<<'<template body>'>>'
   *  with <<template header> = <template name>'('<comma-separated list of attributes>')', and
   *  '<%','%>' is to ignore indentation and newlines in multi-lines template body}
   * </pre>
   * All the attributes set in the template have to be declared as arguments of the template name,
   * even those not used in the template body. And all the attributes used in the template body have
   * to be declared as arguments of the template name. Otherwise an error will occur. This behaviour
   * enforce the control of what is expected by the template.
   */
  @Override
  public String applyFileTemplateDescriptor(String descriptor) {
    return applyTemplate(descriptor, getGroupDir);
  }

  @Override
  public String applyStringTemplate(String template) {
    ST compiledTemplate = new ST(template, '$', '$');
    return applyAttributes(compiledTemplate);
  }

  protected String applyAttributes(ST template) {
    for (Map.Entry<String, Object> attribute : attributes.entrySet()) {
      template.add(attribute.getKey(), attribute.getValue());
    }

    try (StringWriter writer = new StringWriter()) {
      STWriter out = new AutoIndentWriter(writer);
      template.write(out);
      return writer.toString();
    } catch (IOException e) {
      return template.toString();
    }
  }

  @Override
  public void setAttribute(String name, Object value) {
    if (value instanceof String && StringUtil.isNotDefined((String) value)) {
      // It exists no reason to get true on conditional if performed on a not defined string.
      value = null;
    }
    attributes.put(name, value);
  }

  @Override
  public Map<String, Object> getAttributes() {
    return attributes;
  }

  @Override
  public String applyFileTemplateOnComponent(String componentName, String fileName) {
    return applyFileTemplate("/" + componentName.toLowerCase() + "/" + fileName);
  }

  @Override
  public boolean isCustomTemplateExists(String componentName, String fileName) {
    String customersRootDir = templateConfig.getProperty(TEMPLATE_CUSTOM_DIR);
    return isTemplateFileExist(Path.of(customersRootDir, componentName.toLowerCase()), fileName);
  }

  private final TriFunction<String, Charset, Character, STGroup> getRawGroupDir =
      (templateDir, charset, token) -> new STRawGroupDir(templateDir, charset.name(), token, token);

  private final TriFunction<String, Charset, Character, STGroup> getGroupDir =
      (templateDir, charset, token) -> new STGroupDir(templateDir, charset.name(), token, token);

  private String applyTemplate(String fileName,
      TriFunction<String, Charset, Character, STGroup> groupGetter) {
    return paths.stream()
        .filter(p -> Files.isDirectory(Path.of(p)))
        .map(p -> {
          var g = groupGetter.apply(p, Charsets.UTF_8, '$');
          g.registerRenderer(String.class, new StringRenderer());
          g.registerRenderer(Date.class, new DateRenderer());
          return g;
        })
        .map(g -> g.getInstanceOf(fileName))
        .filter(Objects::nonNull)
        .findFirst()
        .map(this::applyAttributes)
        .orElse("");
  }

  private boolean isTemplateFileExist(final Path rootDir, final String fileName) {
    String f = fileName.toLowerCase().endsWith(".st") ? fileName : fileName + ".st";
    return Files.isRegularFile(rootDir.resolve(f));
  }

  @FunctionalInterface
  private interface TriFunction<T, U, V, R> {
    R apply(T t, U u, V v);
  }
}
